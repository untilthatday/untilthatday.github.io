<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[素数判定]]></title>
    <url>%2Fundefined%2F%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[素数是除了1和本身没有其他因数的数。判断一个数是否是素数 对于一个数的素数判定，可以通过遍历它的所有因数，如果它的因数个数大于2，则它不是素数，否则它是素数。当遍历它的所有因数时，我们可以从1遍历到sqrt(n)，因为当一个数的因数肯定是一个大于等于sqrt(n)，另一个大于等于sqrt(n)的，所以当我们遍历所有因数时，遍历到sqrt(n)时，如果有除1以外的其他因数，则这个数不是素数，附上代码。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int i; for(i=2;i&lt;=sqrt(n);i++)&#123;//因为1肯定是n的因数所以可以不遍历 if(n%i==0)&#123;//判断从2到sqrt(n)中是否有n的因数 break; &#125; &#125; if(i&gt;sqrt(n))&#123; cout&lt;&lt;n&lt;&lt;"是素数"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;n&lt;&lt;"不是素数"&lt;&lt;endl; &#125;&#125;~~~ 判断一系列数中有哪些数是素数 对于此类问题，可以通过求一个素数的思维，对一个数组中的数都判断一次就可以了，及在上述代码中加一个循环遍历数组中的每一个元素，但是这时候的时间复杂度很高，对于每一个数的时间复杂度为O(sqrt(n))，遍历所有数，一般都会T。所以我们不在介绍那种方法。 首先，对于一个素数来说，它除了1和自己没有其他的因数，所以每个素数的倍数都不可能是素数，因为它有其他因数，那么我们先假设所有的数都是素数，然后从2开始遍历，找到素数之后，就把素数的倍数全部变为非素数，这样可以把时间复杂度压缩到O(nlogn)，接下来附上代码。代码：~~~c#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;const int Maxn=1000000;bool ispri[Maxn];int num[Maxn];int ans[Maxn];void solve()&#123; fill(ispri,ispri+Maxn,true); ispri[1]=false;//1是非素数 for(int i=2;i&lt;Maxn;i++)&#123; if(ispri[i])&#123;//如果是素数 for(int j=i+i;j&lt;Maxn;j+=i)&#123; ispri[j]=false;//素数的倍数都为非素数 &#125; &#125; &#125;&#125;int main()&#123; solve(); int n; int len=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; int m; cin&gt;&gt;m; if(ispri[m])&#123;//如果是素数，则存入ans ans[len++]=m; &#125; &#125; for(int i=0;i&lt;len;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125; return 0;&#125; 还有一种O(n)的算法，但是博主还没有理解，下次再写吧，哈哈。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome(poj-3974)]]></title>
    <url>%2Fundefined%2FPalindrome(POJ-3974)%2F</url>
    <content type="text"><![CDATA[题目描述Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, “Can you propose an efficient algorithm to find the length of the largest palindrome in a string?” A string is said to be a palindrome if it reads the same both forwards and backwards, for example “madam” is a palindrome while “acm” is not. The students recognized that this is a classical problem but couldn’t come up with a solution better than iterating over all substrings and checking whether they are palindrome or not, obviously this algorithm is not efficient at all, after a while Andy raised his hand and said “Okay, I’ve a better algorithm” and before he starts to explain his idea he stopped for a moment and then said “Well, I’ve an even better algorithm!”. If you think you know Andy’s final solution then prove it! Given a string of at most 1000000 characters find and print the length of the largest palindrome inside this string.InputYour program will be tested on at most 30 test cases, each test case is given as a string of at most 1000000 lowercase characters on a line by itself. The input is terminated by a line that starts with the string “END” (quotes for clarity).OutputFor each test case in the input print the test case number and the length of the largest palindrome.Sample Input 123abcbabcbabcbaabacacbaaaabEND Sample Output 12Case 1: 13Case 2: 6 题目大意：题目给你一些字符串，寻找到该字符串的最大回文子串，当处理到”END”时结束。题解：本题就是典型的manachr算法模板题，把manachr模板带进去就可以AC了，接下来请看代码。代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char arr[2100000],new_arr[2100000];int p[2100000];void newstr()&#123; new_arr[0]=&apos;$&apos;; new_arr[1]=&apos;#&apos;; int len=strlen(arr); int k=2; for(int i=0;i&lt;len;i++)&#123; new_arr[k++]=arr[i]; new_arr[k++]=&apos;#&apos;; &#125; new_arr[k]=&apos;\0&apos;;&#125;int malache()&#123; int id=0,mx=0,maxl=0; int len=strlen(new_arr); fill(p,p+len,0); for(int i=1;i&lt;len;i++)&#123; if(i&lt;mx)&#123; p[i]=min(p[2*id-i],mx-i); &#125; else&#123; p[i]=1; &#125; while(new_arr[i-p[i]]==new_arr[i+p[i]])&#123; p[i]++; &#125; if(p[i]+i&gt;mx)&#123; id=i; mx=p[i]+i; &#125; maxl=max(maxl,p[i]-1); &#125; return maxl;&#125;int main()&#123; int k=1; while(scanf(&quot;%s&quot;,arr)!=EOF &amp;&amp; strcmp(arr,&quot;END&quot;))&#123; newstr(); printf(&quot;Case %d: %d\n&quot;,k++,malache()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>manachr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aladdin and the Flying Carpet (唯一分解定理)]]></title>
    <url>%2Fundefined%2Flightoj(1341)%2F</url>
    <content type="text"><![CDATA[题目描述It’s said that Aladdin had to solve seven mysteries before getting the Magical Lamp which summons a powerful Genie. Here we are concerned about the first mystery. Aladdin was about to enter to a magical cave, led by the evil sorcerer who disguised himself as Aladdin’s uncle, found a strange magical flying carpet at the entrance. There were some strange creatures guarding the entrance of the cave. Aladdin could run, but he knew that there was a high chance of getting caught. So, he decided to use the magical flying carpet. The carpet was rectangular shaped, but not square shaped. Aladdin took the carpet and with the help of it he passed the entrance. Now you are given the area of the carpet and the length of the minimum possible side of the carpet, your task is to find how many types of carpets are possible. For example, the area of the carpet 12, and the minimum possible side of the carpet is 2, then there can be two types of carpets and their sides are: {2, 6} and {3, 4}. InputInput starts with an integer T (≤ 4000), denoting the number of test cases. Each case starts with a line containing two integers: a b (1 ≤ b ≤ a ≤ 1012) where a denotes the area of the carpet and b denotes the minimum possible side of the carpet. OutputFor each case, print the case number and the number of possible carpets. Sample Input 123210 212 2 Sample Output 12Case 1: 1Case 2: 2 题目大意为：给你n和m，让你求n的因子中大于或等于m的个数。这道题我开始直接暴力，及直接从m开始计算，处理到sqrt(n)，算这之间的的因子个数，但是直接T了，所以使用了唯一分解定理。以下是百度百科对于唯一分解定理（算术基本定理）的解释：算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积N=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt;P3……&lt;Pn均为质数，其中指数ai是正整数。这样的分解称为 N 的标准分解式。最早证明是由欧几里得给出的，现代是由陈述证明。此定理可推广至更一般的交换代数和代数数论。我们可以通过此定理直接计算n的所有因子个数，及计算ai的值，然后对于每个pi我们就有(ai+1)中选法，不选和选x个。然后在计算小于m的因子个数，由总的因子个数减去小于m的因子个数就得到答案了。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int Maxn=1e6+5;vector&lt;int&gt; pri;bool ispri[Maxn];ll all(ll n)&#123; int i=0; ll ans=1; int len=pri.size(); while(i&lt;len &amp;&amp; n&gt;1)&#123; int num=0; while(n%pri[i]==0)&#123; num++; n/=pri[i]; &#125; i++; ans*=(num+1); &#125; if(n&gt;1) //如果n&gt;1，说明此时的n还是一个因数，并且没有被计算到，所以乘以(1+1) ans&lt;&lt;=1; ans&gt;&gt;=1; //计算得到的是因数的总个数，我们只需要求它的因数对数，所以除以2 return ans;&#125;ll yin(ll n,ll m)&#123; int ans=0; for(int i=1;i&lt;m;i++)&#123; if(n%i==0)&#123; ans++; &#125; &#125; return ans;&#125;void privis()&#123; fill(ispri,ispri+Maxn,true); for(int i=2;i&lt;1e6;i++)&#123; if(ispri[i])&#123; for(int j=i+i;j&lt;=1e6;j+=i)&#123; ispri[j]=false; &#125; &#125; &#125; pri.clear(); for(int i=2;i&lt;=1e6;i++)&#123; if(ispri[i]) pri.push_back(i); &#125;&#125;int main()&#123; privis(); ll t; scanf(&quot;%d&quot;,&amp;t); for(ll i=1;i&lt;=t;i++)&#123; ll s,m; cin&gt;&gt;s&gt;&gt;m; if(m&gt;sqrt(s))&#123; printf(&quot;Case %lld: 0\n&quot;,i); &#125; else&#123; ll ans=all(s)-yin(s,m); printf(&quot;Case %lld: %lld\n&quot;,i,ans); &#125; &#125; return 0;&#125; 其实说实话，我也不知道为什么这道题不用唯一分解定理就会T，因为如果不用唯一分解定理，我使用暴力时需要从m处理到sqrt(n)，时间时间复杂度为O(n)，如果使用唯一分解定理时，只是计算小于m的因数个数时间复杂度就和暴力时同样为O(n)，博主对于该定理只是有很肤浅的理解，所以有点不知道，猜测是题目数据的问题，其中的m很小，所以用这种不会T，但是如果有知道的小伙伴可以在评论区留言，感谢你们的指点。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wormholes(POJ-3529）]]></title>
    <url>%2Fundefined%2FPOJ(3529)%2F</url>
    <content type="text"><![CDATA[题目描述While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! Each of FJ’s farms comprises N (1 ≤ N ≤ 500) fields conveniently numbered 1..N, M (1 ≤ M ≤ 2500) paths, and W (1 ≤ W ≤ 200) wormholes. As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) . To help FJ find out whether this is possible or not, he will supply you with complete maps to F (1 ≤ F ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds. InputLine 1: A single integer, F. F farm descriptions follow.Line 1 of each farm: Three space-separated integers respectively: N, M, and WLines 2.. M+1 of each farm: Three space-separated numbers ( S, E, T) that describe, respectively: a bidirectional path between S and E that requires T seconds to traverse. Two fields might be connected by more than one path.Lines M+2.. M+ W+1 of each farm: Three space-separated numbers ( S, E, T) that describe, respectively: A one way path from S to E that also moves the traveler back T seconds.OutputLines 1.. F: For each farm, output “YES” if FJ can achieve his goal, otherwise output “NO” (do not include the quotes).Sample Input 1234567891023 3 11 2 21 3 42 3 13 1 33 2 11 2 32 3 43 1 8 Sample Output 12NOYES Hint 12For farm 1, FJ cannot travel back in time. For farm 2, FJ could travel back in time by the cycle 1-&gt;2-&gt;3-&gt;1, arriving back at his starting location 1 second before he leaves. He could start from anywhere on the cycle to accomplish this. 题目大意识问能否通过虫洞回到过去，虫洞是单向边，还有一些双向边，双向边会吧时间向前推，虫洞单向变会让时间倒退，我们把虫洞看成负权边，那么本题就是求这个图是否有负权环。所以可用求最短路的算法SPFA来做，但是只用SPFA可能会T，所以可以通过链式前向星来创邻接表。代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct edge&#123; int u,v,w,next;&#125;;edge e[10050];const int INF=0x3f3f3f3f;int dis[10050],head[10050],cnt;int n,m,w;int vis[10050],num[10050];//链式前向星创建邻接表void add(int u,int v,int w)&#123; e[cnt].u=u; e[cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt++;&#125;bool spfa()&#123; fill(vis,vis+10050,0); fill(num,num+10050,0); fill(dis,dis+10050,INF); queue&lt;int&gt; q; dis[1]=0; q.push(1); num[1]++; while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];i!=-1;i=e[i].next)&#123; int v=e[i].v; if(dis[v]&gt;dis[x]+e[i].w)&#123; dis[v]=dis[x]+e[i].w; if(vis[v]==0)&#123; vis[v]=1; num[v]++; q.push(v); if(num[v]&gt;=n)&#123; return true; &#125; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cnt=0; fill(head,head+10050,-1); scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;w); for(int i=0;i&lt;m;i++)&#123; int u,v,s; cin&gt;&gt;u&gt;&gt;v&gt;&gt;s; add(u,v,s); add(v,u,s); &#125; for(int i=0;i&lt;w;i++)&#123; int u,v,s; cin&gt;&gt;u&gt;&gt;v&gt;&gt;s; add(u,v,-s); &#125; if(spfa())&#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敌兵布阵(HDU 1166)]]></title>
    <url>%2Fundefined%2FHDU(1166)%2F</url>
    <content type="text"><![CDATA[题目描述C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生 变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output 1234Case 1:63359 本题为简单的线段树模板题，直接把线段树模板搬上来就可以了，接下来看代码。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;struct tree&#123; tree *left,*right; int l,r; int date;&#125;;void creattree(tree *&amp;t,int x,int y)&#123; t=new tree; if(x==y)&#123; cin&gt;&gt;t-&gt;date; t-&gt;left=NULL,t-&gt;right=NULL; t-&gt;l=x,t-&gt;r=y; return ; &#125; int mid=x+y&gt;&gt;1; creattree(t-&gt;left,x,mid); creattree(t-&gt;right,mid+1,y); t-&gt;date=t-&gt;left-&gt;date+t-&gt;right-&gt;date; t-&gt;l=t-&gt;left-&gt;l,t-&gt;r=t-&gt;right-&gt;r; return ;&#125;int query(tree *t,int l,int r)&#123; if(t==NULL)&#123; return 0; &#125; if(t-&gt;l&gt;=l &amp;&amp; t-&gt;r&lt;=r)&#123; return t-&gt;date; &#125; if(t-&gt;r&lt;l)&#123; return 0; &#125; if(t-&gt;l&gt;r)&#123; return 0; &#125; int x=t-&gt;l,y=t-&gt;r; int mid=x+y&gt;&gt;1; int num=0; if(mid&gt;=l)&#123; num+=query(t-&gt;left,l,r); &#125; if(mid&lt;r)&#123; num+=query(t-&gt;right,l,r); &#125; return num;&#125;void add(tree *t,int x,int y)&#123; if(t-&gt;l==t-&gt;r)&#123; t-&gt;date+=y; return ; &#125; int mid=t-&gt;l+t-&gt;r&gt;&gt;1; if(mid&lt;x)&#123; add(t-&gt;right,x,y); &#125; else if(mid&gt;=x)&#123; add(t-&gt;left,x,y); &#125; t-&gt;date=t-&gt;left-&gt;date+t-&gt;right-&gt;date; return ;&#125;//释放内存/*void deletion(tree *t)&#123; if(t==NULL)&#123; return ; &#125; deletion(t-&gt;left); deletion(t-&gt;right); delete t;&#125;*/int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=T;i++)&#123; int n; scanf(&quot;%d&quot;,&amp;n); tree *t; creattree(t,1,n); printf(&quot;Case %d:\n&quot;,i); char arr[10]; while(1)&#123; scanf(&quot;%s&quot;,arr); if(strcmp(arr,&quot;End&quot;)==0)&#123; break; &#125; if(strcmp(arr,&quot;Add&quot;)==0)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add(t,x,y); &#125; else if(strcmp(arr,&quot;Sub&quot;)==0)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add(t,x,-y); &#125; else&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;query(t,x,y)&lt;&lt;endl; &#125; &#125; //deletion(t); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cow Contest(POJ-3660)]]></title>
    <url>%2Fundefined%2FCow-Contest-POJ-3660%2F</url>
    <content type="text"><![CDATA[题目描述 N (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors. The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B. Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory. 大意为有n头牛，每头牛能够打败一些牛，然后给你这些牛之间的强弱关系，问通过这些信息能够确定排名的牛的数量。 题解：本题可通过传递闭包求解，即计算能够打败自己的牛，和自己能够打败的牛的数量之和为n-1，那么这头牛的排名是可以确定的，即计算出入度之和为n-1的点的数量。代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int maze[4550][4550];int n,m;void floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) maze[k][i]= maze[k][i] || (maze[k][i]&amp;&amp;maze[j][i]);&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m)&#123; fill(maze[1],maze[1]+n*n,0); while(m--)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; maze[x][y]=1; &#125; floyd(); int ans=0,res=0; for(int i=1;i&lt;=n;i++)&#123; ans=0; for(int j=1;j&lt;=n;j++)&#123; if(i==j) continue; if(maze[i][j] || maze[j][i]) ans++; &#125; if(ans==n-1) res++; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
</search>
