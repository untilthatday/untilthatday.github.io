<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并查集从入门到板子]]></title>
    <url>%2Fundefined%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[并查集是一种数据结构，是一种树形结构，这是百度百科上对并查集的解释： 1并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1~3秒）内计算出试题需要的结果，只能用并查集来描述。 并查集的主要思想是压缩路径，举个栗子：HDU oj 1213题，对]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树模板]]></title>
    <url>%2Fundefined%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[Jungle RoadsTime Limit: 1000MS Memory Limit: 10000KTotal Submissions: 35552 Accepted: 16663 题目链接：http://poj.org/problem?id=1251因为博主太菜了，不会发布图片，所以就只能发链接了，/泪奔 题目描述(ps:因为没有图片，将就着看一下，如果需要看完整提议，请点击上面的链接 /可怜)：DescriptionThe Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems. Input The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 &lt; n &lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.Output The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit.Sample Input 123456789101112139A 2 B 12 I 25B 3 C 10 H 40 I 8C 2 D 18 G 55D 1 E 44E 2 F 60 G 38F 0G 1 H 35H 1 I 353A 2 B 10 C 40B 1 C 200 Sample Output 1221630 题目大意为，在一个小岛上有一些村庄(数量为n)，村庄之间有一些道路，我们可以通过这些道路到达任意一个村庄，但是修缮这些道路是很消费钱的，所以我们需要找到一些道路，让人们可以通过这些道路到达任意一个村庄，并且使得修缮这些道路的费用最低，这就是一个最小生成树的模板题，本题就是求一个该图的最小生成树，我们不介绍最小生成树的定义了。 123最小生成树 锁定本词条由“科普中国”科学百科词条编写与应用工作项目 审核 。一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 [1] 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。 [2] 这是百度百科上对“最小生成树”的解释，接下来我们来看求最小生成树的两种算法：kruskal算法和prim算法，其实这两种算法都是采用的是贪心思想。 kruskalkruskal算法是将所以的边都根据权值排序，每次选择最短的边（这点可以参考求最短路的dijskra算法），然后将这条边加入最小生成树中，但是在加入这条边之前会有一个问题，因为我们是通过加入边的方式寻找最小生成树，所以我们需要考虑这条边两边的节点是否在连通这条边之前就已经连通了，如果已经连通了，那么我们就不需要在添加这条边，否则就加入这条边，怎么去判断两个点是否已经连通了呢？这当然要用到并查集了，因为要连通一个含有n个节点的图，需要n-1条边所以我们需要选择n-1条边。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int inf=0x3f3f3f3f;struct edge&#123; int v,w; int u; edge(int u,int v,int w):u(u),v(v),w(w)&#123;&#125;&#125;;int n;vector&lt;edge&gt; e[30];vector&lt;edge&gt; t;int vis[30];int dis[30];//库鲁斯int f[31];int findfa(int x)&#123; return f[x]=f[x]==x?x:findfa(f[x]);&#125;bool cmp(edge x,edge y)&#123; return x.w&lt;y.w; //对边进行排序，这样每次选择的都是最小边&#125;ll kulus()&#123; for(int i=0;i&lt;n;i++)&#123; f[i]=i; &#125; int len=t.size(); int i=0,j=1; //i记录寻找到第几条边 //j记录最小生成树中即将加入第几条边 ll ans=0; sort(t.begin(),t.end(),cmp); while(i&lt;len &amp;&amp; j&lt;n)&#123;// int u=t[i].u,v=t[i].v,w=t[i].w; //处理第i条边 int tu=findfa(u),tv=findfa(v); //判断这条边两边的点是否已经连通 if(tu!=tv)&#123; //没有联通就将这条边加入最小生成树 f[tv]=tu; j++; ans+=w; &#125; i++; &#125; return ans;&#125;int main()&#123; while(cin&gt;&gt;n,n)&#123; for(int i=0;i&lt;n;i++)&#123; e[i].clear(); &#125; t.clear(); for(int i=1;i&lt;n;i++)&#123; char op; int k; cin&gt;&gt;op&gt;&gt;k; for(int i=0;i&lt;k;i++)&#123; char op1; int x; cin&gt;&gt;op1&gt;&gt;x; e[op-'A'].push_back(edge(op-'A',op1-'A',x)); e[op1-'A'].push_back(edge(op1-'A',op-'A',x)); t.push_back(edge(op-'A',op1-'A',x)); &#125; &#125; ll ans; //ans=prime(0); //cout&lt;&lt;ans&lt;&lt;endl; ans=kulus(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; prim算法prim算法也是采用的贪心思想，与kruskal算法不同的是，kruskal算法是遍历边，从小到大选择边加入最小生成树，而prim算法是先选择一个点加入最小生成树，然后选择离最小生成树中的点距离最小的点加入最小生成树，但是在加入一个点之后可能会对其他点到最小生成树中的点的最小距离长生影响，所以在加入一个点之后就需要更新一下最小距离，保证其他点到最小生成树中的点的距离是最小距离，然后重复上诉操作就行了，因为prim算法是寻找点，所以需要寻找到n个点，但是我们最开始已经加入了一个点，所以我们还需要循环n-1次。代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int inf=0x3f3f3f3f;struct edge&#123; int v,w; int u; edge(int u,int v,int w):u(u),v(v),w(w)&#123;&#125;&#125;;int n;vector&lt;edge&gt; e[30];vector&lt;edge&gt; t;int vis[30];int dis[30];//primell prime(int s)&#123; ll ans=0; memset(vis,0,sizeof vis); //所有点都没有加入最小生成树 memset(dis,inf,sizeof dis); //所有点到最小生成树中的距离为无穷大 for(int i=0;i&lt;e[s].size();i++)&#123; int v=e[s][i].v,w=e[s][i].w; dis[v]=w; //将点s加入最小生成树，并且更新距离 &#125; vis[s]=1; //标记s点 for(int i=1;i&lt;n;i++)&#123; int minn=inf,u=-1; for(int j=0;j&lt;=n;j++)&#123;//寻找离最小生成树最短的点 if(!vis[j] &amp;&amp; dis[j]&lt;minn)&#123; minn=dis[j]; u=j; &#125; &#125; vis[u]=1;//标记点u ans+=minn;//最小生成树的总权值加minn for(int j=0;j&lt;e[u].size();j++)&#123; int v=e[u][j].v,w=e[u][j].w; //更新其他点到最小生成树中的距离 //因为可能其他点到刚加入最小生成树的点的距离更小 dis[v]=min(dis[v],w); &#125; &#125; return ans;&#125;int main()&#123; while(cin&gt;&gt;n,n)&#123; for(int i=0;i&lt;n;i++)&#123; e[i].clear(); &#125; t.clear(); for(int i=1;i&lt;n;i++)&#123; char op; int k; cin&gt;&gt;op&gt;&gt;k; for(int i=0;i&lt;k;i++)&#123; char op1; int x; cin&gt;&gt;op1&gt;&gt;x; e[op-'A'].push_back(edge(op-'A',op1-'A',x)); e[op1-'A'].push_back(edge(op1-'A',op-'A',x)); t.push_back(edge(op-'A',op1-'A',x)); &#125; &#125; ll ans; //ans=prime(0); //cout&lt;&lt;ans&lt;&lt;endl; ans=kulus(); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 上面的代码是上面例题的AC代码，下面附一些例题：HDU 1213:http://acm.hdu.edu.cn/showproblem.php?pid=1213POJ 1251:https://vjudge.net/problem/POJ-1251HDU 1875:https://vjudge.net/problem/HDU-1875HDU 1233:https://vjudge.net/problem/HDU-1233]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最小生成树，Poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD(HDU2588)--欧拉函数]]></title>
    <url>%2Fundefined%2FGCD(HDU2588)--%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[GCD Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 3358 Accepted Submission(s): 1802 Problem DescriptionThe greatest common divisor GCD(a,b) of two positive integers a and b,sometimes written (a,b),is the largest divisor common to a and b,For example,(1,2)=1,(12,18)=6.(a,b) can be easily found by the Euclidean algorithm. Now Carp is considering a little more difficult problem:Given integers N and M, how many integer X satisfies 1&lt;=X&lt;=N and (X,N)&gt;=M. InputThe first line of input is an integer T(T&lt;=100) representing the number of test cases. The following T lines each contains two numbers N and M (2&lt;=N&lt;=1000000000, 1&lt;=M&lt;=N), representing a test case. OutputFor each test case,output the answer on a single line. Sample Input 123431 110 210000 72 Sample Output 12316260 题目大意为，给出一个数N，问有多少个x(1&lt;=x&lt;=N)与N的最大公约数大于等于给出的M。看到这个题的时候我第一反应也是使用欧拉函数，但是却没有想法（暴力天下第一！！），后来看了大佬的博客才知道(太菜了，没办法)。做这个提我们首先要知道一个事实，如果我们已经找到了一个数x使得GCD(N,x)&gt;=M;那么存在一个大于1的整数k使得GCD(N,xk)&gt;=M;那么现在就好办了，只要找到一个数是满足条件的，那么它的倍数也是满足条件的，那么我们要怎样去寻找这个数呢？我们可以找它的因数，首先GCD(N,x)的值是N的因数，如果x是N的因数，那么GCD(N,x)=x，此时GCD(N,xk)&gt;=X,如果x&gt;=m，那么x的任意正整数倍都满足条件，但是要小于N/x倍,所以可以乘以任意一个小于等于N/X的数，此时都满足条件，但是为什么要乘以与N/x互质的数呢？因为为了防止重复计数，因为如果有x和n/x的公倍数小于等于N，就会重复计数，导致答案变大。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll T,n,m,res;ll phi(ll x)&#123; if(x==1) return 1; ll res=x; for(ll i=2;i*i&lt;=x;i++) &#123; if(x%i==0) &#123; res-=res/i; while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res-=res/x; return res;&#125;int main()&#123; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n&gt;&gt;m; res=0; for(ll i=1;i*i&lt;=n;i++) &#123; if(n%i) continue;//只取n的因子，因为其他满足条件的数字可以用 //n的因子*n的因子的素因子来推出来 //比如 10 5--1，2，3，4（与5互质的数） //满足条件的是1*2 2*2 3*2 4*2； if(i&gt;=m&amp;&amp;i*i!=n) res+=phi(n/i); //&amp;&amp;i*i是因为下一步取得时候会重复 //因为这个大于等于m且是10的因子的数，那么gcd（10，它*任意一个数）肯定&gt;=m //这一步就是取了因子*（10/这个因子）的素因子。。10这个样例的2 4 6 8 if(n/i&gt;=m) res+=phi(i); //这边跑的是i的素因子*(10/i) &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>HDU，欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数判定]]></title>
    <url>%2Fundefined%2F%E7%B4%A0%E6%95%B0%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[素数是除了1和本身没有其他因数的数。判断一个数是否是素数 对于一个数的素数判定，可以通过遍历它的所有因数，如果它的因数个数大于2，则它不是素数，否则它是素数。当遍历它的所有因数时，我们可以从1遍历到sqrt(n)，因为当一个数的因数肯定是一个大于等于sqrt(n)，另一个大于等于sqrt(n)的，所以当我们遍历所有因数时，遍历到sqrt(n)时，如果有除1以外的其他因数，则这个数不是素数，附上代码。代码： 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int i; for(i=2;i&lt;=sqrt(n);i++)&#123;//因为1肯定是n的因数所以可以不遍历 if(n%i==0)&#123;//判断从2到sqrt(n)中是否有n的因数 break; &#125; &#125; if(i&gt;sqrt(n))&#123; cout&lt;&lt;n&lt;&lt;&quot;是素数&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;n&lt;&lt;&quot;不是素数&quot;&lt;&lt;endl; &#125;&#125; 判断一系列数中有哪些数是素数 普通筛–埃拉托特尼筛法 对于此类问题，可以通过求一个素数的思维，对一个数组中的数都判断一次就可以了，及在上述代码中加一个循环遍历数组中的每一个元素，但是这时候的时间复杂度很高，对于每一个数的时间复杂度为O(sqrt(n))，遍历所有数，一般都会T。所以我们不在介绍那种方法。 首先，对于一个素数来说，它除了1和自己没有其他的因数，所以每个素数的倍数都不可能是素数，因为它有其他因数，那么我们先假设所有的数都是素数，然后从2开始遍历，找到素数之后，就把素数的倍数全部变为非素数，这样可以把时间复杂度压缩到O(nlogn)，接下来附上代码。代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;const int Maxn=1000000;bool ispri[Maxn];int num[Maxn];int ans[Maxn];void solve()&#123; fill(ispri,ispri+Maxn,true); ispri[1]=false;//1是非素数 for(int i=2;i&lt;Maxn;i++)&#123; if(ispri[i])&#123;//如果是素数 for(int j=i+i;j&lt;Maxn;j+=i)&#123; ispri[j]=false;//素数的倍数都为非素数 &#125; &#125; &#125;&#125;int main()&#123; solve(); int n; int len=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; int m; cin&gt;&gt;m; if(ispri[m])&#123;//如果是素数，则存入ans ans[len++]=m; &#125; &#125; for(int i=0;i&lt;len;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;&apos; &apos;; &#125; return 0;&#125; 线性筛–欧拉Euler筛欧拉筛与埃拉托特尼筛相比效率更高，埃拉托特尼筛是找到一个素数时就将所有的大于它本身的倍数都标记为非素数，这样每次找到了素数都要遍历到边界，并且其中有很多重复的标记，比如两个素数的公倍数，会被重复标记多次，而欧拉筛就考虑到了这个问题，并将这部分重复的问题忽略掉了，欧拉筛是对数遍历，如果是素数，则用一个数组记录它，然后再将所有素数和这个数的乘积标记为非素数，而如果这个数是某一个素数大于它本身的倍数时，可以通过素数筛的后续标记，所以这时可以不用处理。接下来请看代码 123456789101112131415161718void oula()&#123; int len=0; int vis[1000000]=&#123;0&#125;; int ans[1000000]; fill(vis,vis+1000000,1); for(int i=2;i&lt;Maxn;i++)&#123; if(vis[i]=1)&#123;//将素数保存 ans[tot++]=i; &#125; for(int j=1;j&lt;tot &amp;&amp; i*ans[j]&lt;Maxn;j++)&#123; vis[i*ans[j]]=0;//标记素数的倍数为非素数 if(i%ans[j]==0)&#123;//如果i是素数的倍数，那么i的倍数可以通过素数后续的操作标记 break; &#125; &#125; &#125;&#125; 因为大部分都差不多所以我就没写其他的了，就写了一下欧拉筛的函数，（其实博主不会承认是因为懒，小声BB）。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome(poj-3974)]]></title>
    <url>%2Fundefined%2FPalindrome(POJ-3974)%2F</url>
    <content type="text"><![CDATA[题目描述Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, “Can you propose an efficient algorithm to find the length of the largest palindrome in a string?” A string is said to be a palindrome if it reads the same both forwards and backwards, for example “madam” is a palindrome while “acm” is not. The students recognized that this is a classical problem but couldn’t come up with a solution better than iterating over all substrings and checking whether they are palindrome or not, obviously this algorithm is not efficient at all, after a while Andy raised his hand and said “Okay, I’ve a better algorithm” and before he starts to explain his idea he stopped for a moment and then said “Well, I’ve an even better algorithm!”. If you think you know Andy’s final solution then prove it! Given a string of at most 1000000 characters find and print the length of the largest palindrome inside this string.InputYour program will be tested on at most 30 test cases, each test case is given as a string of at most 1000000 lowercase characters on a line by itself. The input is terminated by a line that starts with the string “END” (quotes for clarity).OutputFor each test case in the input print the test case number and the length of the largest palindrome.Sample Input 123abcbabcbabcbaabacacbaaaabEND Sample Output 12Case 1: 13Case 2: 6 题目大意：题目给你一些字符串，寻找到该字符串的最大回文子串，当处理到”END”时结束。题解：本题就是典型的manachr算法模板题，把manachr模板带进去就可以AC了，接下来请看代码。代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char arr[2100000],new_arr[2100000];int p[2100000];void newstr()&#123; new_arr[0]=&apos;$&apos;; new_arr[1]=&apos;#&apos;; int len=strlen(arr); int k=2; for(int i=0;i&lt;len;i++)&#123; new_arr[k++]=arr[i]; new_arr[k++]=&apos;#&apos;; &#125; new_arr[k]=&apos;\0&apos;;&#125;int malache()&#123; int id=0,mx=0,maxl=0; int len=strlen(new_arr); fill(p,p+len,0); for(int i=1;i&lt;len;i++)&#123; if(i&lt;mx)&#123; p[i]=min(p[2*id-i],mx-i); &#125; else&#123; p[i]=1; &#125; while(new_arr[i-p[i]]==new_arr[i+p[i]])&#123; p[i]++; &#125; if(p[i]+i&gt;mx)&#123; id=i; mx=p[i]+i; &#125; maxl=max(maxl,p[i]-1); &#125; return maxl;&#125;int main()&#123; int k=1; while(scanf(&quot;%s&quot;,arr)!=EOF &amp;&amp; strcmp(arr,&quot;END&quot;))&#123; newstr(); printf(&quot;Case %d: %d\n&quot;,k++,malache()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>manachr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Aladdin and the Flying Carpet (唯一分解定理)]]></title>
    <url>%2Fundefined%2Flightoj(1341)%2F</url>
    <content type="text"><![CDATA[题目描述It’s said that Aladdin had to solve seven mysteries before getting the Magical Lamp which summons a powerful Genie. Here we are concerned about the first mystery. Aladdin was about to enter to a magical cave, led by the evil sorcerer who disguised himself as Aladdin’s uncle, found a strange magical flying carpet at the entrance. There were some strange creatures guarding the entrance of the cave. Aladdin could run, but he knew that there was a high chance of getting caught. So, he decided to use the magical flying carpet. The carpet was rectangular shaped, but not square shaped. Aladdin took the carpet and with the help of it he passed the entrance. Now you are given the area of the carpet and the length of the minimum possible side of the carpet, your task is to find how many types of carpets are possible. For example, the area of the carpet 12, and the minimum possible side of the carpet is 2, then there can be two types of carpets and their sides are: {2, 6} and {3, 4}. InputInput starts with an integer T (≤ 4000), denoting the number of test cases. Each case starts with a line containing two integers: a b (1 ≤ b ≤ a ≤ 1012) where a denotes the area of the carpet and b denotes the minimum possible side of the carpet. OutputFor each case, print the case number and the number of possible carpets. Sample Input 123210 212 2 Sample Output 12Case 1: 1Case 2: 2 题目大意为：给你n和m，让你求n的因子中大于或等于m的个数。这道题我开始直接暴力，及直接从m开始计算，处理到sqrt(n)，算这之间的的因子个数，但是直接T了，所以使用了唯一分解定理。以下是百度百科对于唯一分解定理（算术基本定理）的解释：算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积N=P1a1P2a2P3a3……Pnan，这里P1&lt;P2&lt;P3……&lt;Pn均为质数，其中指数ai是正整数。这样的分解称为 N 的标准分解式。最早证明是由欧几里得给出的，现代是由陈述证明。此定理可推广至更一般的交换代数和代数数论。我们可以通过此定理直接计算n的所有因子个数，及计算ai的值，然后对于每个pi我们就有(ai+1)中选法，不选和选x个。然后在计算小于m的因子个数，由总的因子个数减去小于m的因子个数就得到答案了。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int Maxn=1e6+5;vector&lt;int&gt; pri;bool ispri[Maxn];ll all(ll n)&#123; int i=0; ll ans=1; int len=pri.size(); while(i&lt;len &amp;&amp; n&gt;1)&#123; int num=0; while(n%pri[i]==0)&#123; num++; n/=pri[i]; &#125; i++; ans*=(num+1); &#125; if(n&gt;1) //如果n&gt;1，说明此时的n还是一个因数，并且没有被计算到，所以乘以(1+1) ans&lt;&lt;=1; ans&gt;&gt;=1; //计算得到的是因数的总个数，我们只需要求它的因数对数，所以除以2 return ans;&#125;ll yin(ll n,ll m)&#123; int ans=0; for(int i=1;i&lt;m;i++)&#123; if(n%i==0)&#123; ans++; &#125; &#125; return ans;&#125;void privis()&#123; fill(ispri,ispri+Maxn,true); for(int i=2;i&lt;1e6;i++)&#123; if(ispri[i])&#123; for(int j=i+i;j&lt;=1e6;j+=i)&#123; ispri[j]=false; &#125; &#125; &#125; pri.clear(); for(int i=2;i&lt;=1e6;i++)&#123; if(ispri[i]) pri.push_back(i); &#125;&#125;int main()&#123; privis(); ll t; scanf(&quot;%d&quot;,&amp;t); for(ll i=1;i&lt;=t;i++)&#123; ll s,m; cin&gt;&gt;s&gt;&gt;m; if(m&gt;sqrt(s))&#123; printf(&quot;Case %lld: 0\n&quot;,i); &#125; else&#123; ll ans=all(s)-yin(s,m); printf(&quot;Case %lld: %lld\n&quot;,i,ans); &#125; &#125; return 0;&#125; 其实说实话，我也不知道为什么这道题不用唯一分解定理就会T，因为如果不用唯一分解定理，我使用暴力时需要从m处理到sqrt(n)，时间时间复杂度为O(n)，如果使用唯一分解定理时，只是计算小于m的因数个数时间复杂度就和暴力时同样为O(n)，博主对于该定理只是有很肤浅的理解，所以有点不知道，猜测是题目数据的问题，其中的m很小，所以用这种不会T，但是如果有知道的小伙伴可以在评论区留言，感谢你们的指点。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wormholes(POJ-3529）]]></title>
    <url>%2Fundefined%2FPOJ(3529)%2F</url>
    <content type="text"><![CDATA[题目描述While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! Each of FJ’s farms comprises N (1 ≤ N ≤ 500) fields conveniently numbered 1..N, M (1 ≤ M ≤ 2500) paths, and W (1 ≤ W ≤ 200) wormholes. As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) . To help FJ find out whether this is possible or not, he will supply you with complete maps to F (1 ≤ F ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds. InputLine 1: A single integer, F. F farm descriptions follow.Line 1 of each farm: Three space-separated integers respectively: N, M, and WLines 2.. M+1 of each farm: Three space-separated numbers ( S, E, T) that describe, respectively: a bidirectional path between S and E that requires T seconds to traverse. Two fields might be connected by more than one path.Lines M+2.. M+ W+1 of each farm: Three space-separated numbers ( S, E, T) that describe, respectively: A one way path from S to E that also moves the traveler back T seconds.OutputLines 1.. F: For each farm, output “YES” if FJ can achieve his goal, otherwise output “NO” (do not include the quotes).Sample Input 1234567891023 3 11 2 21 3 42 3 13 1 33 2 11 2 32 3 43 1 8 Sample Output 12NOYES Hint 12For farm 1, FJ cannot travel back in time. For farm 2, FJ could travel back in time by the cycle 1-&gt;2-&gt;3-&gt;1, arriving back at his starting location 1 second before he leaves. He could start from anywhere on the cycle to accomplish this. 题目大意识问能否通过虫洞回到过去，虫洞是单向边，还有一些双向边，双向边会吧时间向前推，虫洞单向变会让时间倒退，我们把虫洞看成负权边，那么本题就是求这个图是否有负权环。所以可用求最短路的算法SPFA来做，但是只用SPFA可能会T，所以可以通过链式前向星来创邻接表。代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct edge&#123; int u,v,w,next;&#125;;edge e[10050];const int INF=0x3f3f3f3f;int dis[10050],head[10050],cnt;int n,m,w;int vis[10050],num[10050];//链式前向星创建邻接表void add(int u,int v,int w)&#123; e[cnt].u=u; e[cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt++;&#125;bool spfa()&#123; fill(vis,vis+10050,0); fill(num,num+10050,0); fill(dis,dis+10050,INF); queue&lt;int&gt; q; dis[1]=0; q.push(1); num[1]++; while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];i!=-1;i=e[i].next)&#123; int v=e[i].v; if(dis[v]&gt;dis[x]+e[i].w)&#123; dis[v]=dis[x]+e[i].w; if(vis[v]==0)&#123; vis[v]=1; num[v]++; q.push(v); if(num[v]&gt;=n)&#123; return true; &#125; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cnt=0; fill(head,head+10050,-1); scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;w); for(int i=0;i&lt;m;i++)&#123; int u,v,s; cin&gt;&gt;u&gt;&gt;v&gt;&gt;s; add(u,v,s); add(v,u,s); &#125; for(int i=0;i&lt;w;i++)&#123; int u,v,s; cin&gt;&gt;u&gt;&gt;v&gt;&gt;s; add(u,v,-s); &#125; if(spfa())&#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敌兵布阵(HDU 1166)]]></title>
    <url>%2Fundefined%2FHDU(1166)%2F</url>
    <content type="text"><![CDATA[题目描述C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生 变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output 1234Case 1:63359 本题为简单的线段树模板题，直接把线段树模板搬上来就可以了，接下来看代码。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;struct tree&#123; tree *left,*right; int l,r; int date;&#125;;void creattree(tree *&amp;t,int x,int y)&#123; t=new tree; if(x==y)&#123; cin&gt;&gt;t-&gt;date; t-&gt;left=NULL,t-&gt;right=NULL; t-&gt;l=x,t-&gt;r=y; return ; &#125; int mid=x+y&gt;&gt;1; creattree(t-&gt;left,x,mid); creattree(t-&gt;right,mid+1,y); t-&gt;date=t-&gt;left-&gt;date+t-&gt;right-&gt;date; t-&gt;l=t-&gt;left-&gt;l,t-&gt;r=t-&gt;right-&gt;r; return ;&#125;int query(tree *t,int l,int r)&#123; if(t==NULL)&#123; return 0; &#125; if(t-&gt;l&gt;=l &amp;&amp; t-&gt;r&lt;=r)&#123; return t-&gt;date; &#125; if(t-&gt;r&lt;l)&#123; return 0; &#125; if(t-&gt;l&gt;r)&#123; return 0; &#125; int x=t-&gt;l,y=t-&gt;r; int mid=x+y&gt;&gt;1; int num=0; if(mid&gt;=l)&#123; num+=query(t-&gt;left,l,r); &#125; if(mid&lt;r)&#123; num+=query(t-&gt;right,l,r); &#125; return num;&#125;void add(tree *t,int x,int y)&#123; if(t-&gt;l==t-&gt;r)&#123; t-&gt;date+=y; return ; &#125; int mid=t-&gt;l+t-&gt;r&gt;&gt;1; if(mid&lt;x)&#123; add(t-&gt;right,x,y); &#125; else if(mid&gt;=x)&#123; add(t-&gt;left,x,y); &#125; t-&gt;date=t-&gt;left-&gt;date+t-&gt;right-&gt;date; return ;&#125;//释放内存/*void deletion(tree *t)&#123; if(t==NULL)&#123; return ; &#125; deletion(t-&gt;left); deletion(t-&gt;right); delete t;&#125;*/int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=T;i++)&#123; int n; scanf(&quot;%d&quot;,&amp;n); tree *t; creattree(t,1,n); printf(&quot;Case %d:\n&quot;,i); char arr[10]; while(1)&#123; scanf(&quot;%s&quot;,arr); if(strcmp(arr,&quot;End&quot;)==0)&#123; break; &#125; if(strcmp(arr,&quot;Add&quot;)==0)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add(t,x,y); &#125; else if(strcmp(arr,&quot;Sub&quot;)==0)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add(t,x,-y); &#125; else&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;query(t,x,y)&lt;&lt;endl; &#125; &#125; //deletion(t); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cow Contest(POJ-3660)]]></title>
    <url>%2Fundefined%2FCow-Contest-POJ-3660%2F</url>
    <content type="text"><![CDATA[题目描述 N (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors. The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B. Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory. 大意为有n头牛，每头牛能够打败一些牛，然后给你这些牛之间的强弱关系，问通过这些信息能够确定排名的牛的数量。 题解：本题可通过传递闭包求解，即计算能够打败自己的牛，和自己能够打败的牛的数量之和为n-1，那么这头牛的排名是可以确定的，即计算出入度之和为n-1的点的数量。代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int maze[4550][4550];int n,m;void floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) maze[k][i]= maze[k][i] || (maze[k][i]&amp;&amp;maze[j][i]);&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m)&#123; fill(maze[1],maze[1]+n*n,0); while(m--)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; maze[x][y]=1; &#125; floyd(); int ans=0,res=0; for(int i=1;i&lt;=n;i++)&#123; ans=0; for(int j=1;j&lt;=n;j++)&#123; if(i==j) continue; if(maze[i][j] || maze[j][i]) ans++; &#125; if(ans==n-1) res++; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
</search>
