<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Wormholes(POJ-3529）]]></title>
    <url>%2Fundefined%2FPOJ(3529)%2F</url>
    <content type="text"><![CDATA[题目描述While exploring his many farms, Farmer John has discovered a number of amazing wormholes. A wormhole is very peculiar because it is a one-way path that delivers you to its destination at a time that is BEFORE you entered the wormhole! Each of FJ’s farms comprises N (1 ≤ N ≤ 500) fields conveniently numbered 1..N, M (1 ≤ M ≤ 2500) paths, and W (1 ≤ W ≤ 200) wormholes. As FJ is an avid time-traveling fan, he wants to do the following: start at some field, travel through some paths and wormholes, and return to the starting field a time before his initial departure. Perhaps he will be able to meet himself :) . To help FJ find out whether this is possible or not, he will supply you with complete maps to F (1 ≤ F ≤ 5) of his farms. No paths will take longer than 10,000 seconds to travel and no wormhole can bring FJ back in time by more than 10,000 seconds. InputLine 1: A single integer, F. F farm descriptions follow.Line 1 of each farm: Three space-separated integers respectively: N, M, and WLines 2.. M+1 of each farm: Three space-separated numbers ( S, E, T) that describe, respectively: a bidirectional path between S and E that requires T seconds to traverse. Two fields might be connected by more than one path.Lines M+2.. M+ W+1 of each farm: Three space-separated numbers ( S, E, T) that describe, respectively: A one way path from S to E that also moves the traveler back T seconds.OutputLines 1.. F: For each farm, output “YES” if FJ can achieve his goal, otherwise output “NO” (do not include the quotes).Sample Input 1234567891023 3 11 2 21 3 42 3 13 1 33 2 11 2 32 3 43 1 8 Sample Output 12NOYES Hint 12For farm 1, FJ cannot travel back in time. For farm 2, FJ could travel back in time by the cycle 1-&gt;2-&gt;3-&gt;1, arriving back at his starting location 1 second before he leaves. He could start from anywhere on the cycle to accomplish this. 题目大意识问能否通过虫洞回到过去，虫洞是单向边，还有一些双向边，双向边会吧时间向前推，虫洞单向变会让时间倒退，我们把虫洞看成负权边，那么本题就是求这个图是否有负权环。所以可用求最短路的算法SPFA来做，但是只用SPFA可能会T，所以可以通过链式前向星来创邻接表。代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct edge&#123; int u,v,w,next;&#125;;edge e[10050];const int INF=0x3f3f3f3f;int dis[10050],head[10050],cnt;int n,m,w;int vis[10050],num[10050];//链式前向星创建邻接表void add(int u,int v,int w)&#123; e[cnt].u=u; e[cnt].v=v; e[cnt].w=w; e[cnt].next=head[u]; head[u]=cnt++;&#125;bool spfa()&#123; fill(vis,vis+10050,0); fill(num,num+10050,0); fill(dis,dis+10050,INF); queue&lt;int&gt; q; dis[1]=0; q.push(1); num[1]++; while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];i!=-1;i=e[i].next)&#123; int v=e[i].v; if(dis[v]&gt;dis[x]+e[i].w)&#123; dis[v]=dis[x]+e[i].w; if(vis[v]==0)&#123; vis[v]=1; num[v]++; q.push(v); if(num[v]&gt;=n)&#123; return true; &#125; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cnt=0; fill(head,head+10050,-1); scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;w); for(int i=0;i&lt;m;i++)&#123; int u,v,s; cin&gt;&gt;u&gt;&gt;v&gt;&gt;s; add(u,v,s); add(v,u,s); &#125; for(int i=0;i&lt;w;i++)&#123; int u,v,s; cin&gt;&gt;u&gt;&gt;v&gt;&gt;s; add(u,v,-s); &#125; if(spfa())&#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敌兵布阵(HDU 1166)]]></title>
    <url>%2Fundefined%2FHDU(1166)%2F</url>
    <content type="text"><![CDATA[题目描述C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生 变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input 123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output 1234Case 1:63359 本题为简单的线段树模板题，直接把线段树模板搬上来就可以了，接下来看代码。代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;struct tree&#123; tree *left,*right; int l,r; int date;&#125;;void creattree(tree *&amp;t,int x,int y)&#123; t=new tree; if(x==y)&#123; cin&gt;&gt;t-&gt;date; t-&gt;left=NULL,t-&gt;right=NULL; t-&gt;l=x,t-&gt;r=y; return ; &#125; int mid=x+y&gt;&gt;1; creattree(t-&gt;left,x,mid); creattree(t-&gt;right,mid+1,y); t-&gt;date=t-&gt;left-&gt;date+t-&gt;right-&gt;date; t-&gt;l=t-&gt;left-&gt;l,t-&gt;r=t-&gt;right-&gt;r; return ;&#125;int query(tree *t,int l,int r)&#123; if(t==NULL)&#123; return 0; &#125; if(t-&gt;l&gt;=l &amp;&amp; t-&gt;r&lt;=r)&#123; return t-&gt;date; &#125; if(t-&gt;r&lt;l)&#123; return 0; &#125; if(t-&gt;l&gt;r)&#123; return 0; &#125; int x=t-&gt;l,y=t-&gt;r; int mid=x+y&gt;&gt;1; int num=0; if(mid&gt;=l)&#123; num+=query(t-&gt;left,l,r); &#125; if(mid&lt;r)&#123; num+=query(t-&gt;right,l,r); &#125; return num;&#125;void add(tree *t,int x,int y)&#123; if(t-&gt;l==t-&gt;r)&#123; t-&gt;date+=y; return ; &#125; int mid=t-&gt;l+t-&gt;r&gt;&gt;1; if(mid&lt;x)&#123; add(t-&gt;right,x,y); &#125; else if(mid&gt;=x)&#123; add(t-&gt;left,x,y); &#125; t-&gt;date=t-&gt;left-&gt;date+t-&gt;right-&gt;date; return ;&#125;//释放内存/*void deletion(tree *t)&#123; if(t==NULL)&#123; return ; &#125; deletion(t-&gt;left); deletion(t-&gt;right); delete t;&#125;*/int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=T;i++)&#123; int n; scanf(&quot;%d&quot;,&amp;n); tree *t; creattree(t,1,n); printf(&quot;Case %d:\n&quot;,i); char arr[10]; while(1)&#123; scanf(&quot;%s&quot;,arr); if(strcmp(arr,&quot;End&quot;)==0)&#123; break; &#125; if(strcmp(arr,&quot;Add&quot;)==0)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add(t,x,y); &#125; else if(strcmp(arr,&quot;Sub&quot;)==0)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; add(t,x,-y); &#125; else&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;query(t,x,y)&lt;&lt;endl; &#125; &#125; //deletion(t); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cow Contest(POJ-3660)]]></title>
    <url>%2Fundefined%2FCow-Contest-POJ-3660%2F</url>
    <content type="text"><![CDATA[题目描述 N (1 ≤ N ≤ 100) cows, conveniently numbered 1..N, are participating in a programming contest. As we all know, some cows code better than others. Each cow has a certain constant skill rating that is unique among the competitors. The contest is conducted in several head-to-head rounds, each between two cows. If cow A has a greater skill level than cow B (1 ≤ A ≤ N; 1 ≤ B ≤ N; A ≠ B), then cow A will always beat cow B. Farmer John is trying to rank the cows by skill level. Given a list the results of M (1 ≤ M ≤ 4,500) two-cow rounds, determine the number of cows whose ranks can be precisely determined from the results. It is guaranteed that the results of the rounds will not be contradictory. 大意为有n头牛，每头牛能够打败一些牛，然后给你这些牛之间的强弱关系，问通过这些信息能够确定排名的牛的数量。 题解：本题可通过传递闭包求解，即计算能够打败自己的牛，和自己能够打败的牛的数量之和为n-1，那么这头牛的排名是可以确定的，即计算出入度之和为n-1的点的数量。代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int maze[4550][4550];int n,m;void floyd()&#123; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) maze[k][i]= maze[k][i] || (maze[k][i]&amp;&amp;maze[j][i]);&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m)&#123; fill(maze[1],maze[1]+n*n,0); while(m--)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; maze[x][y]=1; &#125; floyd(); int ans=0,res=0; for(int i=1;i&lt;=n;i++)&#123; ans=0; for(int j=1;j&lt;=n;j++)&#123; if(i==j) continue; if(maze[i][j] || maze[j][i]) ans++; &#125; if(ans==n-1) res++; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
</search>
